package com.company;

import com.company.indicators.IndicatorAdxAdv;
<<<<<<< Updated upstream
=======
import com.company.indicators.IndicatorPPAdv;
>>>>>>> Stashed changes
import com.company.indicators.IndicatorSMAAdv;
import com.google.gson.Gson;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;

import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * Message Broker
 * Event loop:
 * - Market Data Receiver
 * - Data analyzer -> Analyze trading opportunities
 * - Position Manager
 * - Risk Manager
 * - Trade Executor
 * Database
 * <p>
 * ==============
 * Trend and range detection
<<<<<<< Updated upstream
 * - S&R breakout
 * - Stationarity tests
 * - => Average Directional Index indicator (0 - 100)
 */
public class ManagerSmaAdxStrat {
  public static final String[] PAIRS_ARR = {
          /*"IOTBTC", */"XRPBTC"/*, "BTCUSD", "LTCBTC", "ETHBTC",
          "NEOBTC", "EOSBTC", "TRXBTC", "QTMBTC",
          "XTZBTC"*/, "XLMBTC", "XVGBTC", "VETBTC"};
=======
 * - => S&R breakout/bounce
 * - Stationarity tests
 * - Average Directional Index indicator (0 - 100)
 */
public class ManagerSRStrat {
  public static final String[] PAIRS_ARR = {
          /*"IOTBTC", "XRPBTC", "BTCUSD", "LTCBTC", */"ETHBTC"/*,
          "NEOBTC", "EOSBTC", "TRXBTC", "QTMBTC",
          "XTZBTC", "XLMBTC", "XVGBTC", "VETBTC"*/};
>>>>>>> Stashed changes

  private Map<String, StategyData> pairs;
  private BfxTrade bfxTrade;
  private int openedPositions;
  private int successes;
  private int losses;
  private double exchangeFees = 0.4; //0.4 pct
<<<<<<< Updated upstream
  private double trendStrength = 25;

  public ManagerSmaAdxStrat() {
=======

  public ManagerSRStrat() {
>>>>>>> Stashed changes
    pairs = new HashMap<>();
    bfxTrade = new BfxTrade();
  }

<<<<<<< Updated upstream
  public ManagerSmaAdxStrat init() {
    for (String pair : PAIRS_ARR) {
      final StategyData stategyData = new StategyData();
      stategyData.setIndicatorSMAAdv(new IndicatorSMAAdv(21, new ArrayList<>()));
      stategyData.setIndicatorAdxAdv(new IndicatorAdxAdv(14, new ArrayList<>(), new ArrayList<>(), new ArrayList<>())); // close, high, low
=======
  public ManagerSRStrat init() {
    for (String pair : PAIRS_ARR) {
      final StategyData stategyData = new StategyData();
      stategyData.setIndicatorSMAAdv(new IndicatorSMAAdv(21, new ArrayList<>()));
      stategyData.setIndicatorPPAdv(new IndicatorPPAdv(new ArrayList<>(), new ArrayList<>(), new ArrayList<>()));
>>>>>>> Stashed changes
      pairs.put(pair, stategyData);
    }
    return this;
  }

  public void runBot() {
<<<<<<< Updated upstream
    final Map<String, List<BotCandle>> marketData = initMarketData();

    for (int i = 0; i < /*marketData.get(PAIRS_ARR[0]).size()*/50; i++) {
      for (String pair : PAIRS_ARR) {
        if (i < marketData.get(pair).size())
          updateIndicators(pair, marketData.get(pair).get(i));
=======
    final Map<String, List<BotCandle>> marketData15m = initMarketData("15m");
    final Map<String, List<BotCandle>> marketData1D = initMarketData("1D");
    System.out.println("market data 15m size " + marketData15m.get(PAIRS_ARR[0]).size() + " converted in days " + marketData15m.get(PAIRS_ARR[0]).size() / 96);
    System.out.println("market data 1d size " + marketData1D.get(PAIRS_ARR[0]).size());

    int index1D = 0;
    for (int i = 0; i < /*marketData15m.get(PAIRS_ARR[0]).size()*/91086; i++) {
      for (String pair : PAIRS_ARR) {
        if (i < marketData15m.get(pair).size())
          updateIndicators(pair, marketData15m.get(pair).get(i));
>>>>>>> Stashed changes
      }
    }
  }

  private void updateIndicators(String pair, BotCandle candle) {
<<<<<<< Updated upstream
    pairs.get(pair).indicatorAdxAdv.nextValue(candle.getClose(), candle.getHigh(), candle.getLow());
    pairs.get(pair).indicatorSMAAdv.nextValue(candle.getClose(), 0).ifPresent(maValue -> {
      pairs.get(pair).setMaValue(maValue);
      findTradeOpportunity(pair, candle.getClose());
      pairs.get(pair).setPreviousMaValue(maValue);
=======
//    pairs.get(pair).indicatorSMAAdv.nextValue(candle.getClose(), 0).ifPresent(maValue -> {
//      pairs.get(pair).setMaValue(maValue);
//      findTradeOpportunity(pair, candle.getClose());
//      pairs.get(pair).setPreviousMaValue(maValue);
//      pairs.get(pair).setPreviousPrice(candle.getClose());
//    });
    pairs.get(pair).indicatorPPAdv.nextValue(candle.getClose(), candle.getHigh(), candle.getLow()).ifPresent(ppValue -> {
      pairs.get(pair).setPpValue(ppValue);
      pairs.get(pair).setR1Value(pairs.get(pair).indicatorPPAdv.getResistance1());
      pairs.get(pair).setS1Value(pairs.get(pair).indicatorPPAdv.getSupport1());
      pairs.get(pair).setR2Value(pairs.get(pair).indicatorPPAdv.getResistance2());
      pairs.get(pair).setS2Value(pairs.get(pair).indicatorPPAdv.getSupport2());
      pairs.get(pair).setR3Value(pairs.get(pair).indicatorPPAdv.getResistance3());
      pairs.get(pair).setS3Value(pairs.get(pair).indicatorPPAdv.getSupport3());
      findTradeOpportunity(pair, candle.getClose());
>>>>>>> Stashed changes
      pairs.get(pair).setPreviousPrice(candle.getClose());
    });
  }

  /**
   * Data analyzer
   *
   * @param pair
   * @param close
   */
  private void findTradeOpportunity(String pair, double close) {
    if (!pairs.get(pair).isOpenLong() && !pairs.get(pair).isOpenShort()) {
<<<<<<< Updated upstream
      if (pairs.get(pair).getPreviousPrice() < pairs.get(pair).getPreviousMaValue()
              && close > pairs.get(pair).getMaValue()
              && pairs.get(pair).getAdxValue() > trendStrength) {
        openLongPosition(pair, close);
      } else if (pairs.get(pair).getPreviousPrice() > pairs.get(pair).getPreviousMaValue() &&
              close < pairs.get(pair).getMaValue()) {
        openShortPosition(pair, close);
      }
    } else if (pairs.get(pair).isOpenLong()) {
      if (close < pairs.get(pair).getMaValue() &&
              close > pairs.get(pair).getEntryPrice() * (1 + exchangeFees / 100)) {
=======
      if (close >= pairs.get(pair).getPpValue() && close <= pairs.get(pair).getPpValue() * (1 + 2/100.0)) {
        openLongPosition(pair, close);
      } else if (close <= pairs.get(pair).getPpValue() && close >= pairs.get(pair).getPpValue() * (1 - 2 / 100.0)) {
        openShortPosition(pair, close);
      }
    } else if (pairs.get(pair).isOpenLong()) {
      if (close >= pairs.get(pair).getR1Value() * (1 - 2/100.0)
              && close < pairs.get(pair).getR1Value() * (1 + 2/100.0) &&
              close > pairs.get(pair).getEntryPrice() * (1 + exchangeFees / 100.0)) {
>>>>>>> Stashed changes
        successes++;
        closeLongPosition(pair, close);
      }
      // check stop loss
      else if (close < pairs.get(pair).getStopLossPrice()) {
        losses++;
        closeLongPosition(pair, pairs.get(pair).getStopLossPrice());
      }
    } else if (pairs.get(pair).isOpenShort()) {
<<<<<<< Updated upstream
      if (close > pairs.get(pair).getMaValue() &&
              close < pairs.get(pair).getEntryPrice() * (1 - exchangeFees / 100)) {
=======
      if (close <= pairs.get(pair).getS1Value() * (1 + 2/100.0) &&
              close < pairs.get(pair).getEntryPrice() * (1 - exchangeFees / 100.0)) {
>>>>>>> Stashed changes
        successes++;
        closeShortPosition(pair, close);
      }
      // check stop loss
      else if (close > pairs.get(pair).getStopLossPrice()) {
        losses++;
        closeShortPosition(pair, pairs.get(pair).getStopLossPrice());
      }
    }
  }

  private void openLongPosition(String pair, double price) {
<<<<<<< Updated upstream
    pairs.get(pair).setStopLossPrice(price * 0.98);
=======
    pairs.get(pair).setStopLossPrice(pairs.get(pair).getPpValue() * 0.98);
>>>>>>> Stashed changes
    pairs.get(pair).setEntryAmount(getPositionSize(price));
    bfxTrade.tesTrade(pair, price, pairs.get(pair).getEntryAmount(), "buy", "long", new Runnable() {
      @Override
      public void run() {
        pairs.get(pair).setOpenLong(true);
        pairs.get(pair).setEntryPrice(price);
        openedPositions++;
        System.out.println(pair + " Opened long position at " + price + " amount " + pairs.get(pair).getEntryAmount());
        System.out.println(pair + " Stop loss price " + pairs.get(pair).getStopLossPrice());
        System.out.println(pair + " Opened positions " + openedPositions);
        System.out.println("---------------------------------------------------------------------------------------------");
      }
    });
  }

  private void openShortPosition(String pair, double price) {
<<<<<<< Updated upstream
    pairs.get(pair).setStopLossPrice(price * 1.02);
=======
    pairs.get(pair).setStopLossPrice(pairs.get(pair).getPpValue() * 1.02);
>>>>>>> Stashed changes
    pairs.get(pair).setEntryAmount(getPositionSize(price));
    bfxTrade.tesTrade(pair, price, pairs.get(pair).getEntryAmount(), "sell", "short", new Runnable() {
      @Override
      public void run() {
        pairs.get(pair).setOpenShort(true);
        pairs.get(pair).setEntryPrice(price);
        openedPositions++;
        System.out.println(pair + " Opened short position at " + price + " amount " + pairs.get(pair).getEntryAmount());
        System.out.println(pair + " Stop loss price " + pairs.get(pair).getStopLossPrice());
        System.out.println(pair + " Opened positions " + openedPositions);
        System.out.println("---------------------------------------------------------------------------------------------");
      }
    });
  }

  private void closeLongPosition(String pair, double price) {
    bfxTrade.tesTrade(pair, price, pairs.get(pair).getEntryAmount(), "sell", "long", new Runnable() {
      @Override
      public void run() {
        System.out.println(pair + " Closed long position at " + price + " amount " + pairs.get(pair).getEntryAmount());
        System.out.println(pair + " Result amount " + bfxTrade.getInitAmount());
        System.out.println(pair + " Successes " + successes + " Losses " + losses);
        System.out.println("---------------------------------------------------------------------------------------------");
        pairs.get(pair).setStopLossPrice(0.0);
        pairs.get(pair).setEntryAmount(0.0);
        pairs.get(pair).setEntryPrice(0.0);
        pairs.get(pair).setOpenLong(false);
        openedPositions--;
      }
    });
  }

  private void closeShortPosition(String pair, double price) {
    bfxTrade.tesTrade(pair, price, pairs.get(pair).getEntryAmount(), "buy", "short", new Runnable() {
      @Override
      public void run() {
        System.out.println(pair + " Closed short position at " + price + " amount " + pairs.get(pair).getEntryAmount());
        System.out.println(pair + " Result amount " + bfxTrade.getInitAmount());
        System.out.println(pair + " Successes " + successes + " Losses " + losses);
        System.out.println("---------------------------------------------------------------------------------------------");
        pairs.get(pair).setStopLossPrice(0.0);
        pairs.get(pair).setEntryAmount(0.0);
        pairs.get(pair).setEntryPrice(0.0);
        pairs.get(pair).setOpenShort(false);
        openedPositions--;
      }
    });
  }

  private double getPositionSize(double price) {
    return (bfxTrade.getInitAmount() / (PAIRS_ARR.length - openedPositions)) / price;
  }

<<<<<<< Updated upstream
  private Map<String, List<BotCandle>> initMarketData() {
    String timeFrame = "15m";
=======
  private Map<String, List<BotCandle>> initMarketData(String timeFrame) {
>>>>>>> Stashed changes
    Map<String, List<BotCandle>> marketData = new HashMap<>();
    final Type BOTCANDLE_TYPE = new TypeToken<List<BotCandle>>() {
    }.getType();
    Gson gson = new Gson();
    for (String pair : PAIRS_ARR) {
      JsonReader jsonReader = null;
      FileReader fileReader = null;
      try {
        try {
          fileReader = new FileReader("BFX_" + pair + "_" + timeFrame + "_Output.json");
        } catch (FileNotFoundException e) {
          e.printStackTrace();
        }
        jsonReader = new JsonReader(fileReader);
        List<BotCandle> data = gson.fromJson(jsonReader, BOTCANDLE_TYPE);
        Collections.sort(data, new BotCandleTimeComparator());
        marketData.put(pair, data);
      } finally {
        try {
          fileReader.close();
          jsonReader.close();
        } catch (IOException e) {
          e.printStackTrace();
        }
      }
      //System.out.println(pair + " " + marketData.get(pair).size());
    }
    return marketData;
  }

  private class StategyData {
    private IndicatorSMAAdv indicatorSMAAdv;
<<<<<<< Updated upstream
    private IndicatorAdxAdv indicatorAdxAdv;
    private double maValue;
    private double adxValue;
=======
    private IndicatorPPAdv indicatorPPAdv;
    private double maValue;
    private double ppValue;
>>>>>>> Stashed changes
    private double previousMaValue;
    private double previousPrice;
    private boolean openLong = false;
    private boolean openShort = false;
    private double stopLossPrice;
    private double entryAmount;
    private double entryPrice;
<<<<<<< Updated upstream

    public void setIndicatorAdxAdv(IndicatorAdxAdv indicatorAdxAdv) {
      this.indicatorAdxAdv = indicatorAdxAdv;
    }

=======
    private double s1Value;
    private double r1Value;
    private double s2Value;
    private double r2Value;
    private double s3Value;
    private double r3Value;


    public void setIndicatorPPAdv(IndicatorPPAdv indicatorPPAdv) {
      this.indicatorPPAdv = indicatorPPAdv;
    }
>>>>>>> Stashed changes
    public void setIndicatorSMAAdv(IndicatorSMAAdv indicatorSMAAdv) {
      this.indicatorSMAAdv = indicatorSMAAdv;
    }

<<<<<<< Updated upstream
=======
    public void setPpValue(double ppValue) {
      this.ppValue = ppValue;
    }

    public double getPpValue() {
      return ppValue;
    }

>>>>>>> Stashed changes
    public void setMaValue(double maValue) {
      this.maValue = maValue;
    }

    public double getMaValue() {
      return maValue;
    }

    public double getPreviousMaValue() {
      return previousMaValue;
    }

    public void setPreviousMaValue(double previousMaValue) {
      this.previousMaValue = previousMaValue;
    }

    public double getPreviousPrice() {
      return previousPrice;
    }

    public void setPreviousPrice(double previousPrice) {
      this.previousPrice = previousPrice;
    }

    public boolean isOpenLong() {
      return openLong;
    }

    public void setOpenLong(boolean openLong) {
      this.openLong = openLong;
    }

    public boolean isOpenShort() {
      return openShort;
    }

    public void setOpenShort(boolean openShort) {
      this.openShort = openShort;
    }

    public double getStopLossPrice() {
      return stopLossPrice;
    }

    public void setStopLossPrice(double stopLossPrice) {
      this.stopLossPrice = stopLossPrice;
    }

    public double getEntryAmount() {
      return entryAmount;
    }

    public void setEntryAmount(double entryAmount) {
      this.entryAmount = entryAmount;
    }

    public double getEntryPrice() {
      return entryPrice;
    }

    public void setEntryPrice(double entryPrice) {
      this.entryPrice = entryPrice;
    }

<<<<<<< Updated upstream
    public double getAdxValue() {
      return adxValue;
    }

    public void setAdxValue(double adxValue) {
      this.adxValue = adxValue;
=======
    public double getS1Value() {
      return s1Value;
    }

    public void setS1Value(double s1Value) {
      this.s1Value = s1Value;
    }

    public double getR1Value() {
      return r1Value;
    }

    public void setR1Value(double r1Value) {
      this.r1Value = r1Value;
    }

    public double getS2Value() {
      return s2Value;
    }

    public void setS2Value(double s2Value) {
      this.s2Value = s2Value;
    }

    public double getR2Value() {
      return r2Value;
    }

    public void setR2Value(double r2Value) {
      this.r2Value = r2Value;
    }

    public double getS3Value() {
      return s3Value;
    }

    public void setS3Value(double sValue) {
      this.s3Value = sValue;
    }

    public double getR3Value() {
      return r3Value;
    }

    public void setR3Value(double r3Value) {
      this.r3Value = r3Value;
>>>>>>> Stashed changes
    }
  }
}
